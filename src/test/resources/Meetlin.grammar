{{{package test;

import SyntaxNode
import at.searles.lexer.Lexer
import at.searles.lexer.SkipTokenizer
import at.searles.parsing.Mapping
import at.searles.parsing.Parser
import at.searles.parsing.Reducer
import at.searles.parsing.Ref
import at.searles.parsing.tools.generator.Context
import at.searles.regex.CharSet
import at.searles.regex.Regex

}}}

grammar Meetlin {
{{{
    private val tokenizer = SkipTokenizer(Lexer())
    private val context = Context(tokenizer)
}}}

    regex ws: [\x09\x0b\r \xa0\u1680\u2000-\u200a\u202f\u205f\u3000]+ ;
	regex nl: "\r\n" | "\n" | "\x0c" | "\x85" | "\u2028" | "\u2029" ; // keep newlines separated for formatting.
    regex slComment: ('/*' .* '*/')! ;
    regex mlComment: '//' ([^\n] | [^\r])* ;

{{{    init {
        tokenizer.addSkipped(ws.tokenId)
        tokenizer.addSkipped(nl.tokenId)
        tokenizer.addSkipped(slComment.tokenId)
        tokenizer.addSkipped(mlComment.tokenId)
    }
}}}

    fragment intRex: [0-9]{1,8} ;
    fragment hexRex: [0-9A-Fa-f]{1,8} ;
    fragment decimals: '.'[0-9]* ;
    fragment exponent: [eE]'-'?[0-9]+ ;
    fragment realRex: [0-9]+(decimals | exponent | decimals exponent) ;
    fragment identifierRex: [a-zA-Z_][a-zA-Z0-9_]* ;
    fragment stringRex: ('"' ([^\\"] | '\\'. )* '"') ;

    intNum: regex(intRex, `toInt`) ;
    realNum: regex(realRex, `toReal`) ;
    hexNum: regex(hexRex, `toHex`) ;
    str: regex(stringRex, `toEscString`) ;
    identifier: regex(identifierRex, `toIdString`) ;

    intNode: (intNum | hexNum) `toIntNode` ;
    realNode: realNum `toRealNode` ;
    stringNode: str `toStringNode` ;
    idNode: identifier `toIdNode` ;

    comma: ',' ;
    exprList: `emptyList` `comma.join(expr.fold(append))` ;

    vectorNode: '[' exprList `toVectorNode` ']' ;

    atom: intNode
        | realNode
        | stringNode
        | idNode
        | vectorNode
        | '(' expr ')' ;

    qualified: atom ('.' atom >> `toQualified`)* ;

    arguments: '(' exprList ')' (app >> `listApply`)? | app `toSingleton` ;

    app<SyntaxNode>: qualified (arguments >> `toApp`)? ; // recursive because of eg "sin cos x"

    ifExpr<SyntaxNode>: 'if' `properties`
                        '(' expr >> `set("condition")` ')'
                        stmt >> `set("thenBranch")`
                        (
							'else' stmt >> `put("elseBranch")`
								`Mapping.create(If.class, true, "condition", "thenBranch", "elseBranch")`
							| `Mapping.create(If.class, true, "condition", "thenBranch")`
						) ;

	block: '{' stmts `toBlock` '}' ;

	absExpr: '|' expr `toAbs` '|' ;

    term: app | ifExpr | block | absExpr ;

    literal<SyntaxNode>: ('-' `Neg` | '/' `Recip` ) literal >> `toUnary`
                       | literal
                       ;

    cplxCons: literal (':' literal >> `toBinary(CplxCons)`)? ;

    pow: cplxCons ('^' cplxCons >> `toBinary(CplxCons)`)* ;

    product: pow ('*' pow >> `toBinary(Mul)` | '/' pow >> `toBinary(Div)` | '%'  pow >> `toBinary(Mod)` )* ;

    sum: product ('+' product >> `toBinary(Add)` | '-' product >> `toBinary(Sub)` )* ;

	cmp : sum
		( '>' sum >> `toBinary(Greater)`
		| '>=' sum >> `toBinary(GreaterEqual)`
		| '<=' sum >> `toBinary(LessEqual)`
		| '<' sum >> `toBinary(Less)`
		| '==' sum >> `toBinary(Equal)`
		| '!=' sum >> `toBinary(NotEqual)`
		)? ;

	logicalLit: 'not' `Not` cmp `toUnary` | cmp ;
	logicalAnd: logicalLit ('and' logicalLit >> `toBinary(And)`)* ;
	logicalXor: logicalAnd ('xor' logicalAnd >> `toBinary(Xor)`)* ;
	logicalOr: logicalXor ('or' logicalXor >> `toBinary(Or)`)* ;

	expr<SyntaxNode>: logicalOr ;

	exprstmt: expr ('=' expr >> `toBinary(Assign)`)? ;

	whilestmt: 'while' `properties`
			   '(' expr >> `put("condition")` ')'
			   (stmt >> `put("body")`)?
			   `create(While.class, true, "condition", body)` ;

	forstmt: 'for' `properties` '(' name >> `put("name")` 'in' expr >> `put("range")` ')' stmt  >> `put("body")`
			 `create(For.class, true, "name", "range", "body")`;

	stmt<SyntaxNode>: (exprstmt | whilestmt | forstmt) ';'? ;

	vardecl: 'var' `properties` name >> `put("name")`
				(':' type >> `put("type")`)?
				('=' expr >> `put("init")`)?
				`create(Var.class, "name", "type", "init")` ;

	argument: 'var' id (':' type >> `TypedVarArg` | `VarArg` ) | idNode ;
	arguments: `list` `comma.join(argument.fold(append))` ;

	fundecl: 'fun' `properties` name >> `put("name")`
				'(' arguments >> `put("arguments")` ')'
				block >> `put("body")`
				`create(Fun.class, "name", "arguments", "body")` ;

	classdecl: 'class' `properties` name >> `put("name")`
				('(' arguments ')' | `list`) >> `put("arguments")
				block >> `put("body")
				`create(Clazz.class, "name", "arguments", "body")` ;

	defdecl: 'def' name '=' expr ; // alias.

	decl: (vardecl | fundecl | classdecl | defdecl) ';'? ;

	stmts<`List<SyntaxNode>`>: `list` ((stmt | decl) >> `append`)* ;
	program: stmts `toBlock` ;
}